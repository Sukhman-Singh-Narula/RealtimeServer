<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß∏ StoryTeller Dashboard</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .status-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .status-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
        }

        .status-card.connected {
            border-color: #28a745;
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
        }

        .status-card.connecting {
            border-color: #ffc107;
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
        }

        .status-card.disconnected {
            border-color: #dc3545;
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
        }

        .status-card h3 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .status-card .value {
            font-size: 2rem;
            font-weight: bold;
            margin: 10px 0;
        }

        .control-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .control-panel h2 {
            margin-bottom: 20px;
            color: #667eea;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            justify-content: center;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #e83e8c);
            color: white;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .volume-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .stats-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
        }

        .logs-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .logs {
            background: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            padding: 20px;
            border-radius: 10px;
            height: 400px;
            overflow-y: auto;
            border: 2px solid #333;
            white-space: pre-wrap;
            line-height: 1.4;
        }

        .logs::-webkit-scrollbar {
            width: 8px;
        }

        .logs::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        .logs::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        .alert {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid;
        }

        .alert-success {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .alert-warning {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }

        .alert-error {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .device-list {
            list-style: none;
            padding: 0;
        }

        .device-item {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .device-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .device-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
        }

        .status-disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-connecting {
            background: #fff3cd;
            color: #856404;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .status-grid {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
            }

            .btn {
                min-width: auto;
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üß∏ StoryTeller Dashboard</h1>
            <p>AI-Powered Conversational Teddy Bear Server</p>
        </div>

        <!-- Connection Status -->
        <div class="status-grid">
            <div class="status-card" id="connection-card">
                <h3>Connection Status</h3>
                <div class="value" id="connection-status">Disconnected</div>
                <small id="connection-details">Click connect to start</small>
            </div>
            <div class="status-card">
                <h3>Audio System</h3>
                <div class="value" id="audio-status">üîá Not initialized</div>
                <small id="audio-details">Audio system ready</small>
            </div>
            <div class="status-card">
                <h3>Messages</h3>
                <div class="value" id="message-count">0 ‚ÜóÔ∏è 0 ‚ÜôÔ∏è</div>
                <small>Sent / Received</small>
            </div>
            <div class="status-card">
                <h3>Audio Chunks</h3>
                <div class="value" id="audio-chunks">0</div>
                <small>AI voice chunks received</small>
            </div>
        </div>

        <!-- Connection Controls -->
        <div class="control-panel">
            <h2>Connection Controls</h2>
            <div class="button-group">
                <button class="btn btn-success" id="connect-btn" onclick="connectToServer()">
                    üîå Connect to Server
                </button>
                <button class="btn btn-danger" id="disconnect-btn" onclick="disconnectFromServer()" disabled>
                    üîå Disconnect
                </button>
                <button class="btn btn-primary" id="test-audio-btn" onclick="sendTestAudio()" disabled>
                    üéµ Send Test Audio
                </button>
                <button class="btn btn-warning" id="end-conversation-btn" onclick="endConversation()" disabled>
                    üèÅ End Conversation
                </button>
            </div>

            <div class="volume-control">
                <span>üîä Volume:</span>
                <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="80"
                    oninput="setVolume(this.value)">
                <span id="volume-display">80%</span>
            </div>
        </div>

        <!-- Recording Controls -->
        <div class="control-panel">
            <h2>Recording Controls</h2>
            <div class="button-group">
                <button class="btn btn-success" id="start-recording-btn" onclick="startRecording()" disabled>
                    üéôÔ∏è Start Recording
                </button>
                <button class="btn btn-danger" id="stop-recording-btn" onclick="stopRecording()" disabled>
                    üõë Stop Recording
                </button>
            </div>
            <div class="alert alert-warning">
                <strong>Note:</strong> Recording controls simulate voice input. In production, these would capture real
                audio from microphone.
            </div>
        </div>

        <!-- Statistics -->
        <div class="stats-panel">
            <h2>Real-time Statistics</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Connection Time</div>
                    <div class="stat-value" id="connection-time">0s</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Audio Queue</div>
                    <div class="stat-value" id="audio-queue">0 chunks</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Bytes</div>
                    <div class="stat-value" id="total-bytes">0 B</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Playback Status</div>
                    <div class="stat-value" id="playback-status">üîá Idle</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Errors</div>
                    <div class="stat-value" id="error-count">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Reconnect Attempts</div>
                    <div class="stat-value" id="reconnect-attempts">0</div>
                </div>
            </div>
        </div>

        <!-- Server Status -->
        <div class="stats-panel">
            <h2>Server Information</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Server Uptime</div>
                    <div class="stat-value" id="server-uptime">Loading...</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Active Devices</div>
                    <div class="stat-value" id="server-devices">Loading...</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Conversations</div>
                    <div class="stat-value" id="server-conversations">Loading...</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">OpenAI Status</div>
                    <div class="stat-value" id="openai-status">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Device List -->
        <div class="control-panel">
            <h2>Connected Devices</h2>
            <ul id="device-list" class="device-list">
                <li class="device-item">
                    <div class="device-info">
                        <span>üì± No devices connected</span>
                    </div>
                </li>
            </ul>
        </div>

        <!-- Console Logs -->
        <div class="logs-panel">
            <h2>Live Console Logs</h2>
            <div id="logs" class="logs">Initializing StoryTeller Dashboard...
                Ready to connect to server.
                Click "Connect to Server" to begin.
            </div>
        </div>
    </div>

    <!-- Include the complete audio handler -->
    <script>
        // Complete Audio Stream Handler (from previous artifact)
        class AudioStreamHandler {
            constructor() {
                this.audioContext = null;
                this.audioQueue = [];
                this.isPlaying = false;
                this.sampleRate = 24000;
                this.currentGain = null;
                this.isInitialized = false;
                this.totalBytesReceived = 0;
                this.totalChunksReceived = 0;
                this.currentSource = null;
                this.playbackStartTime = null;
            }

            async initialize() {
                try {
                    logToConsole('üéµ Initializing audio system...');

                    if (!window.AudioContext && !window.webkitAudioContext) {
                        throw new Error('Web Audio API not supported');
                    }

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate,
                        latencyHint: 'interactive'
                    });

                    this.currentGain = this.audioContext.createGain();
                    this.currentGain.connect(this.audioContext.destination);
                    this.currentGain.gain.value = 0.8;

                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    this.isInitialized = true;
                    logToConsole('  Audio system initialized successfully');
                    updateAudioStatus('üîä Ready', 'Audio system initialized');

                    return true;
                } catch (error) {
                    logToConsole('  Failed to initialize audio: ' + error.message);
                    updateAudioStatus('  Failed', error.message);
                    return false;
                }
            }

            async handleAudioChunk(base64Audio) {
                try {
                    if (!this.isInitialized) {
                        const success = await this.initialize();
                        if (!success) return;
                    }

                    if (!base64Audio || base64Audio.length === 0) {
                        logToConsole('Empty audio chunk received');
                        return;
                    }

                    this.totalChunksReceived++;
                    logToConsole(`üéµ Processing audio chunk ${this.totalChunksReceived}`);

                    const binaryString = atob(base64Audio);
                    const bytes = new Uint8Array(binaryString.length);

                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    this.totalBytesReceived += bytes.length;
                    const pcmData = new Int16Array(bytes.buffer);

                    if (pcmData.length === 0) return;

                    const floatData = new Float32Array(pcmData.length);
                    for (let i = 0; i < pcmData.length; i++) {
                        floatData[i] = Math.max(-1, Math.min(1, pcmData[i] / 32768.0));
                    }

                    const audioBuffer = this.audioContext.createBuffer(1, floatData.length, this.sampleRate);
                    audioBuffer.copyToChannel(floatData, 0);

                    this.audioQueue.push({
                        buffer: audioBuffer,
                        timestamp: Date.now(),
                        chunkNumber: this.totalChunksReceived
                    });

                    updateStats();

                    if (!this.isPlaying) {
                        await this.startPlayback();
                    }

                } catch (error) {
                    logToConsole('  Error processing audio chunk: ' + error.message);
                }
            }

            async startPlayback() {
                if (this.isPlaying || this.audioQueue.length === 0) return;

                logToConsole('üîä Starting audio playback');
                this.isPlaying = true;
                this.playbackStartTime = Date.now();
                updateAudioStatus('üîä Playing', 'AI is speaking');

                await this.playNextChunk();
            }

            async playNextChunk() {
                try {
                    if (this.audioQueue.length === 0) {
                        logToConsole('üîá Audio queue empty, stopping playback');
                        this.isPlaying = false;
                        this.currentSource = null;
                        updateAudioStatus('üîä Ready', 'Waiting for audio');
                        return;
                    }

                    const audioChunk = this.audioQueue.shift();
                    const audioBuffer = audioChunk.buffer;

                    logToConsole(`üîä Playing chunk ${audioChunk.chunkNumber}: ${audioBuffer.duration.toFixed(3)}s`);

                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(this.currentGain);

                    this.currentSource = source;

                    source.onended = () => {
                        setTimeout(() => {
                            if (this.isPlaying) {
                                this.playNextChunk();
                            }
                        }, 10);
                    };

                    source.onerror = (error) => {
                        logToConsole(`  Audio playback error for chunk ${audioChunk.chunkNumber}`);
                        setTimeout(() => {
                            if (this.isPlaying) {
                                this.playNextChunk();
                            }
                        }, 50);
                    };

                    source.start(0);
                    updateStats();

                } catch (error) {
                    logToConsole('  Error in playNextChunk: ' + error.message);
                    setTimeout(() => {
                        if (this.isPlaying && this.audioQueue.length > 0) {
                            this.playNextChunk();
                        } else {
                            this.isPlaying = false;
                        }
                    }, 100);
                }
            }

            handleAudioComplete() {
                logToConsole('  Audio response stream complete');
                logToConsole(`   Total chunks: ${this.totalChunksReceived}, bytes: ${this.totalBytesReceived}`);
                updateAudioStatus('  Complete', 'AI finished speaking');
            }

            setVolume(volume) {
                if (this.currentGain) {
                    const clampedVolume = Math.max(0, Math.min(1, volume));
                    this.currentGain.gain.value = clampedVolume;
                    logToConsole(`üîä Volume set to: ${Math.round(clampedVolume * 100)}%`);
                }
            }

            getPlaybackStats() {
                return {
                    isPlaying: this.isPlaying,
                    queueLength: this.audioQueue.length,
                    totalChunksReceived: this.totalChunksReceived,
                    totalBytesReceived: this.totalBytesReceived,
                    playbackTime: this.playbackStartTime ? Date.now() - this.playbackStartTime : 0,
                    audioContextState: this.audioContext ? this.audioContext.state : 'not initialized'
                };
            }

            async stop() {
                logToConsole('üõë Stopping audio playback');
                this.isPlaying = false;
                this.audioQueue = [];

                if (this.currentSource) {
                    try {
                        this.currentSource.stop();
                        this.currentSource = null;
                    } catch (error) {
                        // Ignore stop errors
                    }
                }

                if (this.audioContext && this.audioContext.state !== 'closed') {
                    try {
                        await this.audioContext.close();
                        this.audioContext = null;
                        this.currentGain = null;
                        this.isInitialized = false;
                    } catch (error) {
                        // Ignore close errors
                    }
                }

                this.totalBytesReceived = 0;
                this.totalChunksReceived = 0;
                this.playbackStartTime = null;
                updateAudioStatus('üîá Stopped', 'Audio system stopped');
            }
        }

        // Enhanced WebSocket Manager
        class StoryTellerWebSocketManager {
            constructor() {
                this.ws = null;
                this.audioHandler = new AudioStreamHandler();
                this.deviceId = 'TEST_DEVICE_001';
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 2000;
                this.messageStats = {
                    sent: 0,
                    received: 0,
                    audioChunks: 0,
                    errors: 0
                };
                this.connectionStartTime = null;
                this.lastMessageTime = null;
            }

            async connect() {
                try {
                    logToConsole('üîå Initializing StoryTeller connection...');
                    updateConnectionStatus('Connecting...', 'connecting');

                    const audioReady = await this.audioHandler.initialize();
                    if (!audioReady) {
                        throw new Error('Failed to initialize audio system');
                    }

                    const wsUrl = `ws://localhost:8000/upload/${this.deviceId}`;
                    logToConsole(`üîå Connecting to: ${wsUrl}`);

                    this.ws = new WebSocket(wsUrl);
                    this.connectionStartTime = Date.now();

                    this.ws.onopen = () => {
                        logToConsole('  WebSocket connected successfully!');
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.reconnectDelay = 2000;
                        updateConnectionStatus('Connected', 'connected');
                        updateButtonStates(true);
                    };

                    this.ws.onmessage = async (event) => {
                        this.lastMessageTime = Date.now();
                        this.messageStats.received++;

                        try {
                            const data = JSON.parse(event.data);
                            await this.handleServerMessage(data);
                        } catch (error) {
                            logToConsole('  Error parsing message: ' + error.message);
                            this.messageStats.errors++;
                        }
                        updateStats();
                    };

                    this.ws.onerror = (error) => {
                        logToConsole('  WebSocket error: ' + error);
                        this.messageStats.errors++;
                        updateConnectionStatus('Error', 'disconnected');
                    };

                    this.ws.onclose = (event) => {
                        logToConsole(`üîå WebSocket closed: ${event.code} ${event.reason}`);
                        this.isConnected = false;
                        updateConnectionStatus('Disconnected', 'disconnected');
                        updateButtonStates(false);

                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.reconnectAttempts++;
                            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
                            logToConsole(`üîÑ Reconnecting in ${delay}ms... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                            updateConnectionStatus(`Reconnecting in ${delay / 1000}s...`, 'connecting');

                            setTimeout(() => this.connect(), delay);
                        } else {
                            logToConsole('  Max reconnection attempts reached');
                            updateConnectionStatus('Failed', 'disconnected');
                        }
                        updateStats();
                    };

                } catch (error) {
                    logToConsole('  Connection failed: ' + error.message);
                    updateConnectionStatus('Failed', 'disconnected');
                    this.messageStats.errors++;
                    updateStats();
                }
            }

            async handleServerMessage(data) {
                const messageType = data.type;
                logToConsole(`üì• Received: ${messageType}`);

                switch (messageType) {
                    case 'connected':
                        logToConsole('üéØ Server connection confirmed');
                        updateConnectionStatus('Starting conversation...', 'connected');
                        break;

                    case 'audio_chunk':
                        this.messageStats.audioChunks++;
                        await this.audioHandler.handleAudioChunk(data.audio);
                        updateConnectionStatus(`Playing AI response... (${this.messageStats.audioChunks} chunks)`, 'connected');
                        break;

                    case 'audio_complete':
                        logToConsole('  AI response complete');
                        this.audioHandler.handleAudioComplete();
                        updateConnectionStatus('AI finished - You can respond', 'connected');
                        break;

                    case 'conversation_started':
                        logToConsole('üé¨ Conversation started');
                        updateConnectionStatus('Conversation active', 'connected');
                        break;

                    case 'conversation_ended':
                        logToConsole('üèÅ Conversation ended');
                        updateConnectionStatus('Conversation ended', 'connected');
                        await this.audioHandler.stop();
                        break;

                    case 'error':
                        logToConsole('  Server error: ' + data.message);
                        updateConnectionStatus(`Error: ${data.message}`, 'disconnected');
                        this.messageStats.errors++;
                        break;

                    case 'keepalive':
                        logToConsole('üíì Keepalive received');
                        break;

                    default:
                        logToConsole(`üì• Unknown message: ${messageType}`);
                        break;
                }
            }

            sendMessage(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        this.ws.send(JSON.stringify(data));
                        this.messageStats.sent++;
                        logToConsole(`üì§ Sent: ${data.type}`);
                        updateStats();
                        return true;
                    } catch (error) {
                        logToConsole('  Error sending message: ' + error.message);
                        this.messageStats.errors++;
                        updateStats();
                        return false;
                    }
                } else {
                    logToConsole('‚ö†Ô∏è WebSocket not connected');
                    return false;
                }
            }

            sendTestAudio() {
                if (!this.isConnected) {
                    logToConsole('‚ö†Ô∏è Not connected - cannot send audio');
                    return;
                }

                logToConsole('üéµ Generating and sending test audio...');

                const sampleRate = 16000;
                const duration = 2;
                const frequency = 440;
                const samples = sampleRate * duration;

                const audioData = new Int16Array(samples);
                for (let i = 0; i < samples; i++) {
                    audioData[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) * 16384;
                }

                const bytes = new Uint8Array(audioData.buffer);
                const base64Audio = btoa(String.fromCharCode.apply(null, bytes));

                this.sendMessage({
                    type: 'audio_data',
                    audio: base64Audio
                });

                setTimeout(() => {
                    this.sendMessage({
                        type: 'stop_recording'
                    });
                }, 100);
            }

            getStats() {
                const audioStats = this.audioHandler.getPlaybackStats();
                const connectionTime = this.connectionStartTime ? Date.now() - this.connectionStartTime : 0;

                return {
                    connection: {
                        isConnected: this.isConnected,
                        deviceId: this.deviceId,
                        connectionTime: connectionTime,
                        reconnectAttempts: this.reconnectAttempts,
                        lastMessageTime: this.lastMessageTime
                    },
                    messages: this.messageStats,
                    audio: audioStats
                };
            }

            async disconnect() {
                logToConsole('üîå Disconnecting...');
                this.reconnectAttempts = this.maxReconnectAttempts;

                await this.audioHandler.stop();

                if (this.ws) {
                    this.ws.close(1000, 'Manual disconnect');
                }

                updateConnectionStatus('Disconnected', 'disconnected');
                updateButtonStates(false);
            }
        }

        // Global variables
        let wsManager = null;
        let serverStatsInterval = null;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            logToConsole('üöÄ StoryTeller Dashboard Initialized');
            wsManager = new StoryTellerWebSocketManager();

            // Start fetching server stats
            fetchServerStats();
            serverStatsInterval = setInterval(fetchServerStats, 5000);

            // Update stats display every second
            setInterval(updateStats, 1000);
        });

        // UI Update Functions
        function updateConnectionStatus(status, state) {
            const statusElement = document.getElementById('connection-status');
            const detailsElement = document.getElementById('connection-details');
            const cardElement = document.getElementById('connection-card');

            if (statusElement) statusElement.textContent = status;
            if (detailsElement) detailsElement.textContent = `Device: ${wsManager.deviceId}`;

            if (cardElement) {
                cardElement.className = `status-card ${state}`;
                if (state === 'connecting') cardElement.classList.add('pulse');
                else cardElement.classList.remove('pulse');
            }
        }

        function updateAudioStatus(status, details) {
            const statusElement = document.getElementById('audio-status');
            const detailsElement = document.getElementById('audio-details');

            if (statusElement) statusElement.textContent = status;
            if (detailsElement) detailsElement.textContent = details;
        }

        function updateButtonStates(connected) {
            document.getElementById('connect-btn').disabled = connected;
            document.getElementById('disconnect-btn').disabled = !connected;
            document.getElementById('test-audio-btn').disabled = !connected;
            document.getElementById('end-conversation-btn').disabled = !connected;
            document.getElementById('start-recording-btn').disabled = !connected;
            document.getElementById('stop-recording-btn').disabled = !connected;
        }

        function updateStats() {
            if (!wsManager) return;

            const stats = wsManager.getStats();

            // Connection stats
            document.getElementById('connection-time').textContent =
                Math.round(stats.connection.connectionTime / 1000) + 's';
            document.getElementById('reconnect-attempts').textContent =
                stats.connection.reconnectAttempts.toString();

            // Message stats
            document.getElementById('message-count').textContent =
                `${stats.messages.sent} ‚ÜóÔ∏è ${stats.messages.received} ‚ÜôÔ∏è`;
            document.getElementById('audio-chunks').textContent =
                stats.messages.audioChunks.toString();
            document.getElementById('error-count').textContent =
                stats.messages.errors.toString();

            // Audio stats
            document.getElementById('audio-queue').textContent =
                `${stats.audio.queueLength} chunks`;
            document.getElementById('total-bytes').textContent =
                formatBytes(stats.audio.totalBytesReceived);
            document.getElementById('playback-status').textContent =
                stats.audio.isPlaying ? 'üîä Playing' : 'üîá Idle';
        }

        async function fetchServerStats() {
            try {
                const response = await fetch('/status');
                const data = await response.json();

                document.getElementById('server-uptime').textContent =
                    Math.round(data.uptime_seconds) + 's';
                document.getElementById('server-devices').textContent =
                    data.active_devices.toString();
                document.getElementById('server-conversations').textContent =
                    data.total_conversations.toString();
                document.getElementById('openai-status').textContent =
                    data.openai_connected ? '  Connected' : '  Not configured';

            } catch (error) {
                logToConsole('‚ö†Ô∏è Failed to fetch server stats: ' + error.message);
            }
        }

        function logToConsole(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;

            console.log(logMessage);

            const logsElement = document.getElementById('logs');
            if (logsElement) {
                logsElement.textContent += logMessage + '\n';
                logsElement.scrollTop = logsElement.scrollHeight;

                // Keep only last 100 lines
                const lines = logsElement.textContent.split('\n');
                if (lines.length > 100) {
                    logsElement.textContent = lines.slice(-100).join('\n');
                }
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Button event handlers
        function connectToServer() {
            if (wsManager) {
                wsManager.connect();
            }
        }

        function disconnectFromServer() {
            if (wsManager) {
                wsManager.disconnect();
            }
        }

        function sendTestAudio() {
            if (wsManager) {
                wsManager.sendTestAudio();
            }
        }

        function startRecording() {
            if (wsManager) {
                wsManager.sendMessage({ type: 'start_recording' });
                logToConsole('üéôÔ∏è Started recording simulation');
            }
        }

        function stopRecording() {
            if (wsManager) {
                wsManager.sendMessage({ type: 'stop_recording' });
                logToConsole('üõë Stopped recording simulation');
            }
        }

        function endConversation() {
            if (wsManager) {
                wsManager.sendMessage({ type: 'button_press' });
                logToConsole('üèÅ Ending conversation');
            }
        }

        function setVolume(value) {
            const volume = value / 100;
            if (wsManager && wsManager.audioHandler) {
                wsManager.audioHandler.setVolume(volume);
            }
            document.getElementById('volume-display').textContent = value + '%';
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (wsManager) {
                wsManager.disconnect();
            }
            if (serverStatsInterval) {
                clearInterval(serverStatsInterval);
            }
        });
    </script>
</body>

</html>